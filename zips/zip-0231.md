> ZIP: 231
> Title: Memo Bundles
> Owners: Jack Grigg <jack@electriccoin.co>
>         Kris Nuttycombe <kris@electriccoin.co>
>         Daira-Emma Hopwood <daira@electriccoin.co>
>         Arya Solhi <arya@zfnd.org>
> Credits: Sean Bowe
>          Nate Wilcox
> Status: Draft
> Category: Consensus / Wallet
> Created: 2024-04-26
> License: MIT


# Terminology

{Edit this to reflect the key words that are actually used.}
The key words "MUST", "REQUIRED", "MUST NOT", "SHOULD", and "MAY" in this
document are to be interpreted as described in BCP 14 [#BCP14]_ when, and
only when, they appear in all capitals.


# Abstract

TBD


# Motivation

In Zcash transaction versions v2-v5, each shielded output contains a ciphertext
comprised of a 52-byte note plaintext, and a corresponding 512-byte memo field.
Recipients can only decrypt the outputs sent to them, and thus can also only
observe the memo fields included with the outputs they can decrypt.

The shielded transaction protocol hides the sender(s) (that is, the addresses
corresponding to the keys used to spend the input notes) from all of the
recipients. For certain kinds of transactions, it is desirable to make one or
more sender addresses available to one or more recipients (for example, a reply
address), and in subsets of those transactions it is desirable to authenticate
the sender addresses (to give the recipient a guarantee that the address is
controlled by a sender of the transaction). These Authenticated Reply Addresses
require zero-knowledge proofs, and for the Orchard protocol these proofs are too
large to fit into a 512-byte memo field.

Something about light client truncation (simplifies the security argument).

In the light client protocol, a recipient need not download full transaction
information if the compact transaction information indicates that they do not
receive any memo in the transaction.


# Requirements

- Recipients can receive memo data that is greater than 512 bytes in length.
- Multiple recipients, across any of the shielded pools, can be given the
  capability to view the same memo data.
- The exact number and exact lengths of distinct decryptable memos should not
  be revealed, even to the transaction recipients, although an upper bound on
  the total length of memo data that the observer does not have the capability
  to view will be leaked.
- A recipient can determine whether or not they have been given the capability
  to view any memo solely by decrypting the note ciphertext.
- Memo chunks within a transaction can be individually pruned without preventing
  the transaction from being verified.
  - As a consequence, a recipient with the capability to view a memo can prune
    all of that memo's chunks.


# Non-requirements

- Recipients do not need to be able to receive multiple memos per note.


# Specification

## Memo bundle

A memo bundle consists of a sequence of 256-byte memo chunks, each individually
encrypted. These memo chunks represent zero or more encrypted memos.

Each transaction may contain a single memo bundle, and a memo bundle may contain
at most 40 memo chunks. This limits the total amount of memo data that can be
conveyed within a single transaction to 10 KiB.

## Memo encryption

During transaction construction, each memo is assigned a 32-byte `memo_key`.
These keys SHOULD be generated randomly, and MUST NOT be used to encrypt more
than one memo within a single transaction.

In shielded bundles, the 512-byte memo field is replaced by `[flag_byte] || memo_key`.

TODO: Define `flag_byte` format. Have one bit for "there is no memo".

The transaction builder generates a 32-byte nonce from a CSPRNG. A new nonce MUST be
generated for each memo bundle.

The symmetric encryption key for a memo is derived from its `memo_key` as follows:

    encryption_key = PRF^{expand}_{memo_key}([0xE0] || nonce)

Each memo is padded to a multiple of 256 bytes with zeroes, and split into
256-byte chunks. Each memo chunk is encrypted with ChaCha20Poly1305 as follows:

    IETF_AEAD_CHACHA20_POLY1305(encryption_key, nonce = I2BEOSP_{88}(counter) || [final_chunk], memo_chunk)

This is a variant of the STREAM construction [#stream]_.
- `counter` is a big-endian chunk counter starting at zero and incrementing by
  one for each subsequent chunk within a particular memo.
- `final_chunk` is the byte `0x01` for the final memo chunk, and `0x00` for all
  preceding chunks.

Finally, the encrypted memo chunks for all memos are combined into a single
sequence using an order-preserving shuffle. Memo chunks from different memos MAY
be interleaved in any order, but memo chunks from the same memo MUST have the
same relative order. The following diagram shows an example shuffle of three
memos:

```
[
    (memo_a, 0),
    (memo_b, 0),
    (memo_a, 1),
    (memo_c, 0),
    (memo_c, 1),
    (memo_a, 2),
]
```

## Memo decryption

When a recipient decrypts a shielded output, they obtain a `memo_key`. From this
they derive `encryption_key` as above, and then proceed as follows:

- Set `counter = 0` and `final_chunk = 0x00`.
- Attempt to decrypt each memo chunk in order.
- Each time decryption succeeds for a memo chunk, increment `counter` by 1, and
  then continue attempting to decrypt subsequent chunks.
- Once all memo chunks have been trial-decrypted once, set `final_chunk = 0x01`
  and then attempt to decrypt the memo chunks again, starting immediately after
  the last successfully-decrypted chunk (or at the start if none were), and
  without incrementing `counter`.
  - This step can be made secret-independent by attempting to decrypt every memo
    chunk again, and ignoring the results of all chunks up to and including the
    last successfully-decrypted chunk.
- If no memo chunk decrypts successfully with `final_chunk = 0x01`, discard any
  memo chunks that were decrypted, and return nothing. Otherwise, concatenate
  the decrypted memo chunks in order and return the concatenation as the memo.

## Encoding in transactions

TODO: Decide whether / how to enable memo data to be pruned from a transaction while still enabling it to be broadcast.

```rust
enum MemoBundle {
    Chunks(Vec<MemoChunk>),
    Pruned {
        memo_bundle_digest: Digest,
    }
}
```

## Transaction sighash

```
memo_chunk_digest = H(AEAD(MemoChunk, memo_key))
memo_bundle_digest = H(concat(memo_chunk_digests))
```

The memo bundle digest structure is a performance optimisation for the case
where all memo chunks in a transaction have been pruned.


# Rationale

## Pruned encoding

The separation of memo data from note data, and the new ability to easily store
variable-length memo data, opens up an attack vector against node operators for
storing arbitrary data. The transaction digest commitments to the memo bundle
are structured such that if a node operator is presented with a memo key (i.e.
they are given the capability to decrypt a particular memo), they can identify
and prune the corresponding memo chunks, while still enabling the transaction to
be validated as part of its corresponding block and broadcast over the network.

Note that broadcasting a partially-pruned transaction means that the pruned
chunks no longer contribute to the upper bound on memo data.

The prunable structure does not introduce a censorship axis; memo bundles do not
reveal which memo chunks correspond to which memos, and therefore a network
adversary cannot selectively censor individual memos. They can censor any/all
chunks within specific transactions, however shielded transactions do not reveal
their senders, recipients, or amounts, and thus also cannot be individually
targeted for censorship.

# Reference implementation

TBD


# References

[^BCP14]: [Information on BCP 14 â€” "RFC 2119: Key words for use in RFCs to Indicate Requirement Levels" and "RFC 8174: Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"](https://www.rfc-editor.org/info/bcp14)
[^protocol]: Zcash Protocol Specification, Version 2024.5.1 [NU6] or later](protocol/protocol.pdf)
[^stream]: [Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance](https://eprint.iacr.org/2015/189)
