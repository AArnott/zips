> ZIP: 231
> Title: Memo Bundles
> Owners: Jack Grigg <jack@electriccoin.co>
>         Kris Nuttycombe <kris@electriccoin.co>
>         Daira-Emma Hopwood <daira@electriccoin.co>
>         Arya Solhi <arya@zfnd.org>
> Credits: Sean Bowe
>          Nate Wilcox
> Status: Draft
> Category: Consensus / Wallet
> Created: 2024-04-26
> License: MIT


# Terminology

{Edit this to reflect the key words that are actually used.}
The key words "MUST", "REQUIRED", "MUST NOT", "SHOULD", and "MAY" in this
document are to be interpreted as described in BCP 14 [#BCP14]_ when, and
only when, they appear in all capitals.


# Abstract

TBD


# Motivation

In Zcash transaction versions v2-v5, each shielded output contains a ciphertext
comprised of a 52-byte note plaintext, and a corresponding 512-byte memo field.
Recipients can only decrypt the outputs sent to them, and thus can also only
observe the memo fields included with the outputs they can decrypt.

The shielded transaction protocol hides the sender(s) (that is, the addresses
corresponding to the keys used to spend the input notes) from all of the
recipients. For certain kinds of transactions, it is desirable to make one or
more sender addresses available to one or more recipients (for example, a reply
address), and in subsets of those transactions it is desirable to authenticate
the sender addresses (to give the recipient a guarantee that the address is
controlled by a sender of the transaction). These Authenticated Reply Addresses
require zero-knowledge proofs, and for the Orchard protocol these proofs are too
large to fit into a 512-byte memo field.

Something about light client truncation (simplifies the security argument).

In the light client protocol, a recipient need not download full transaction
information if the compact transaction information indicates that they do not
receive any memo in the transaction.


# Requirements

- Recipients can receive memo data that is greater than 512 bytes in length.
- Multiple recipients, across any of the shielded pools, can be given the
  capability to view the same memo data.
- The exact number and exact lengths of distinct decryptable memos should not
  be revealed, even to the transaction recipients, although an upper bound on
  the total length of memo data that the observer does not have the capability
  to view will be leaked.
- A recipient can determine whether or not they have been given the capability
  to view any memo solely by decrypting the note ciphertext.
- Memo chunks within a transaction can be individually pruned without preventing
  the transaction from being verified.
  - As a consequence, a recipient with the capability to view a memo can prune
    all of that memo's chunks.


# Non-requirements

- Recipients do not need to be able to receive multiple memos per note.


# Specification

## Memo bundle

A memo bundle consists of a sequence of 256-byte memo chunks, each individually
encrypted. These memo chunks represent zero or more encrypted memos.

Each transaction may contain a single memo bundle, and a memo bundle may contain
at most 40 memo chunks. This limits the total amount of memo data that can be
conveyed within a single transaction to 10 KiB.

Memo bundles are encoded in transactions in a prunable manner: each memo chunk
can be replaced by its representative digest.

## Memo encryption

During transaction construction, each memo is assigned a 32-byte `memo_key`.
These keys SHOULD be generated randomly, and MUST NOT be used to encrypt more
than one memo within a single transaction.

In shielded bundles, the 512-byte memo field is replaced by `[flag_byte] || memo_key`.

TODO: Define `flag_byte` format. Have one bit for "there is no memo".

The transaction builder generates a 32-byte nonce from a CSPRNG. A new nonce MUST be
generated for each memo bundle.

The symmetric encryption key for a memo is derived from its `memo_key` as follows:

    encryption_key = PRF^{expand}_{memo_key}([0xE0] || nonce)

Each memo is padded to a multiple of 256 bytes with zeroes, and split into
256-byte chunks. Each memo chunk is encrypted with ChaCha20Poly1305 as follows:

    IETF_AEAD_CHACHA20_POLY1305(encryption_key, nonce = I2BEOSP_{88}(counter) || [final_chunk], memo_chunk)

This is a variant of the STREAM construction [#stream]_.
- `counter` is a big-endian chunk counter starting at zero and incrementing by
  one for each subsequent chunk within a particular memo.
- `final_chunk` is the byte `0x01` for the final memo chunk, and `0x00` for all
  preceding chunks.

Finally, the encrypted memo chunks for all memos are combined into a single
sequence using an order-preserving shuffle. Memo chunks from different memos MAY
be interleaved in any order, but memo chunks from the same memo MUST have the
same relative order. The following diagram shows an example shuffle of three
memos:

```
[
    (memo_a, 0),
    (memo_b, 0),
    (memo_a, 1),
    (memo_c, 0),
    (memo_c, 1),
    (memo_a, 2),
]
```

## Memo decryption

When a recipient decrypts a shielded output, they obtain a `memo_key`. From this
they derive `encryption_key` as above, and then proceed as follows:

- Set `counter = 0` and `final_chunk = 0x00`.
- Attempt to decrypt each memo chunk in order. Pruned memo chunks are skipped.
- Each time decryption succeeds for a memo chunk, increment `counter` by 1, and
  then continue attempting to decrypt subsequent chunks.
- Once all memo chunks have been trial-decrypted once, set `final_chunk = 0x01`
  and then attempt to decrypt the memo chunks again, starting immediately after
  the last successfully-decrypted chunk (or at the start if none were), and
  without incrementing `counter`.
  - This step can be made secret-independent by attempting to decrypt every memo
    chunk again, and ignoring the results of all chunks up to and including the
    last successfully-decrypted chunk.
- If no memo chunk decrypts successfully with `final_chunk = 0x01`, discard any
  memo chunks that were decrypted, and return nothing. Otherwise, concatenate
  the decrypted memo chunks in order and return the concatenation as the memo.

If any chunk of the memo encrypted to `memo_key` has been pruned, the decryption
process above returns nothing (as `final_chunk` will be set to `0x01` with the
wrong counter value), ensuring that a malformed memo is not returned.

## Encoding in transactions

| Bytes  | Name          | Data Type                | Description                             |
|--------|---------------|--------------------------|---------------------------------------- |
| 32     | `nonce`       | `byte[32]`               | The nonce for deriving encryption keys. |
| 8      | `pruned`      | `uint64`                 | Bitflags indicating the type of each entry in `vMemoChunks`. Bits are little endian. 0 corresponds to `byte[272]` and is an encrypted memo chunk. 1 corresponds to `byte[32]` and is the `memo_chunk_digest` for a pruned chunk. |
| varies | `nMemoChunks` | `compactSize`            | Length of `vMemoChunks`.                |
| varies | `vMemoChunks` | `MemoChunk[nMemoChunks]` | A sequence of encrypted memo chunks.    |

TODO: Decide whether to permit an optimised encoding for a fully-pruned memo
bundle that just contains `memo_bundle_digest`.

## Transaction sighash

```
memo_chunk_digest = H(AEAD(MemoChunk, memo_key))
memo_bundle_digest = H(concat(memo_chunk_digests))
```

The memo bundle digest structure is a performance optimisation for the case
where all memo chunks in a transaction have been pruned.

TODO: finish this to be a modification to the equivalent of ZIP 244 for
transaction v6.

## Transaction fees

(This section will become a modification to ZIP 317.)

A memo bundle may contain two free chunks if there are any shielded outputs in
the transaction. Otherwise, each memo chunk requires `marginal_fee` as defined
in ZIP 317 [#zip-0317]_.

## Consensus rules

TODO: specify.


# Rationale

## Memo bundle size restriction

Restricting the total amount of memo data in a bundle to 10 KiB limits the rate
at which the chain size can grow cheaply (from a computational perspective; memo
bundles are much easier to produce than proofs or signatures).

The current behaviour for previous transaction versions (no limit on the number
of memos) is not altered by this ZIP, because memos in those transactions are
tied to individual shielded outputs (incurring their computational cost), and
are not natively aggregable.

## Memo chunk size

With 10KiB limit on amount of memo data as the constant in this table, the
maximum number of unique memos you can create, and the cost in bytes of that
memo data plus auth when using a 32-byte memo key, is:

|            |                  Memo size                  |
| Chunk size |      ≤ 256 bytes     |       512 bytes      |
|------------|----------------------|----------------------|
|  Pre-231   | 20 @ 10240 (  0.00%) | 20 @ 10240 (  0.00%) |
|    512     | 20 @ 11220 (+ 9.57%) | 20 @ 11220 (+ 9.57%) |
|    256     | 40 @ 12200 (+19.14%) | 20 @ 11540 (+12.70%) |
| 256 20-out | 20 @  6100 (-40.43%) |                      |

In the "256 20-out" case you have a distinguisher compared to old transactions,
in that you can tell the transaction is sending at most 256 bytes per recipient
rather than 512 if it is sending the max number of memos. But that's inherently
baked into the decision to use a smaller memo chunk size (and it is still
possible for the chunks to all be a single memo sent to all outputs, or anything
in between).

## Memo key size

If we used a 16-byte memo key instead of 32 bytes, the transaction size overhead
becomes:

|            |                  Memo size                  |
| Chunk size |      ≤ 256 bytes     |       512 bytes      |
|------------|----------------------|----------------------|
|  Pre-231   | 20 @ 10240 (  0.00%) | 20 @ 10240 (  0.00%) |
|    512     | 20 @ 10900 (+ 6.45%) | 20 @ 10900 (+ 6.45%) |
|    256     | 40 @ 11560 (+12.89%) | 20 @ 11220 (+ 9.57%) |
| 256 20-out | 20 @  5780 (-43.55%) |                      |

The decrease in overhead is relatively modest in most cases, but more noticeable
for small memos with a 256-byte memo chunk.

However, 16-byte memo keys don't meet Zcash's target security level of 125 bits.
The classical argument [#ref]_ is that you can build a machine of size 2^32
("The variant key-search machine") that has a 2^-71 chance of finding a 128-bit
key (with sufficient targets, e.g. 2^36 *blocks*). In this scenario, you only
get 32+71 = 103 bits of security classically.

The benefits of 32-byte keys are:
- They incur a small transaction size overhead above the minimum key size that
  _would_ meet that target security level.
- It is simpler than reasoning about unusual byte lengths for keys.
- This key length matches what we already use elsewhere for symmetric keys.

See also [#protocol-inbandrationale]_.

## Encryption format

Including a per-transaction `nonce` in the derivation of `encryption_key` gives
protection against accidental (or intentional) `memo_key` reuse across multiple
transactions. We do not protect against `memo_key` reuse within a transaction;
it is up to the transaction builder to ensure that the same `memo_key` is not
used to encrypt two different memos (and if they did so, normal clients would
either never observe the second memo, or would decrypt parts of each memo and
get a non-sensical and potentially insecure "spliced" memo).

We do not include commitments to the shielded outputs in the derivation of
`encryption_key` for two reasons:
- It would force the transaction builder to fully define all shielded outputs
  before encrypting the memos, which might prevent potential use cases of PCZTs.
- We don't want to unnecessarily prevent the ability to create a transaction
  with a memo bundle and no shielded outputs, as there may be use cases for,
  e.g. a fully-transparent transaction with encrypted memo, or a ZSA issuance
  transaction with exposed memo data using a well-known `memo_key`.

## Pruned encoding

The separation of memo data from note data, and the new ability to easily store
variable-length memo data, opens up an attack vector against node operators for
storing arbitrary data. The transaction digest commitments to the memo bundle
are structured such that if a node operator is presented with a memo key (i.e.
they are given the capability to decrypt a particular memo), they can identify
and prune the corresponding memo chunks, while still enabling the transaction to
be validated as part of its corresponding block and broadcast over the network.

The transaction encoding permits pruning at the individual chunk level in order
to faciliate pruning an individual memo from a transaction without affecting the
other memos. This enables node operators to be responsive to, for example, GDPR
deletion requests.

Note that broadcasting a partially-pruned transaction means that the pruned
chunks no longer contribute to the upper bound on memo data.

The prunable structure does not introduce a censorship axis; memo bundles do not
reveal which memo chunks correspond to which memos, and therefore a network
adversary cannot selectively censor individual memos. They can censor any/all
chunks within specific transactions, however shielded transactions do not reveal
their senders, recipients, or amounts, and thus also cannot be individually
targeted for censorship.

## Transaction fees

Making the fee linear in the number of chunks has the following properties:

- The required fee to add more memo chunks scales at the same rate as adding
  logical actions, so it isn't a cheaper mechanism for an adversary to bloat
  chain size.
- A "baseline transaction" (one spent note, one output to an external recipient
  with a memo, one change output without a memo) has the same fee as before.
- A "broadcast transaction" (many outputs to different recipients all given the
  same memo) is the same fee as before (but a smaller transaction).
- A "many memos transaction" (many outputs to different recipients all with
  unique memos) is at most around twice the fee as before.

Combined with the memo bundle size restriction, the maximum additional fee for
a memo bundle over prior transactions is 0.0019 ZEC.


# Reference implementation

TBD


# References

[^BCP14]: [Information on BCP 14 — "RFC 2119: Key words for use in RFCs to Indicate Requirement Levels" and "RFC 8174: Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"](https://www.rfc-editor.org/info/bcp14)
[^protocol]: Zcash Protocol Specification, Version 2024.5.1 [NU6] or later](protocol/protocol.pdf)
[^protocol-inbandrationale]: [Zcash Protocol Specification, Version 2024.5.1 [NU6]. Section 8.7: In-band secret distribution](protocol/protocol.pdf#inbandrationale)
[^stream]: [Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance](https://eprint.iacr.org/2015/189)
[^zip-0317]: [ZIP 317: Proportional Transfer Fee Mechanism](zip-0317.rst)
